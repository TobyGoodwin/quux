{
#include "syn.h"
}

Es :: Cell * ← __ f:Form __ Semi? __ e:Es → { syn_sequence(f, e) }
             / __ f:Form __ → f

Form ← Raw
     / Defn
     / Command

Raw ← Quote l:RawList → { cell_car(l) }

Defn ← ws:Words Equals l:List → { syn_define(ws, l) }

Body ← f:Form b:Body → { syn_sequence(f, b) }
     / Form

Command ← i:Item l:List → { syn_command(i, l) }

RawList ← LPar l:RawList RPar k:RawList →
                { list_append(cell_cons(l, cell_nil), k) }
        / w:Word l:RawList → { cell_cons(w, l) }
        / ε → cell_nil

List ← i:Item $ l:List → { cell_cons(i, l) }
     / ε → cell_nil

ListNl ← __ i:Item __ l:ListNl → { cell_cons(i, l) }
       / __ → cell_nil

Item ← Atom
     / Molecule
     
Atom ← Dollar w:Word → w
     / w:Word → { syn_prefix("quote", w) }

Molecule ← LPar $ l:ListNl $ RPar → { cell_cons_string("list", l) }
         / Dollar i:Item → { syn_eval(i) }
         / LBrace e:Es RBrace → { syn_lambda(cell_nil, e) }
         / "if":LexWord i:Item j:Item k:Item -> { syn_if(i, j, k) }

Words ← w:Word ws:Words → { cell_cons(w, ws) }
      / w:Word → { cell_cons(w, cell_nil) }

Word ← w:LexWord → { cell_new_string(ref_dup(w)) }

LexWord :: ref_t ← w:[-0-9A-Za-z%,./:?]+ _ → w

Comment :: void ← "#" [^\n]* "\n"

# horizontal whitespace
_ ← [ \t]*

# any whitespace
__ ← ( [ \t\n] / Comment )*

LBrace ← "{" _
RBrace ← "}" _
Dollar ← "$" _
Equals ← "=" _
LPar ← "(" _
RPar ← ")" _
Quote ← "\"" _
Semi ← ";" _
